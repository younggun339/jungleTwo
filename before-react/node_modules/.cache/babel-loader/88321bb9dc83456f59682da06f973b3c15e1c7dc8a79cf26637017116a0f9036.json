{"ast":null,"code":"// startCapturing.js\n\n/**\n * 비디오 스트림에서 이미지를 캡처하고, 이를 WebSocket을 통해 서버로 전송하는 함수.\n * \n * @param {MediaStream} stream - 비디오 스트림 객체.\n * @param {React.RefObject} ref - 비디오 태그의 ref.\n * @param {React.RefObject} canvasRef - 캔버스 태그의 ref.\n * @param {Socket} socketRef - Socket.IO 클라이언트 인스턴스의 ref.\n */\nconst startCapturing = (stream, ref, canvasRef, socketRef, myIndex) => {\n  const video = ref.current;\n  const canvas = canvasRef.current;\n\n  // 캔버스가 없다면 함수 종료\n  if (!canvas) return;\n  const context = canvas.getContext('2d');\n\n  // 캔버스 크기를 비디오와 동일하게 설정\n  const resizeCanvas = () => {\n    canvas.width = video.videoWidth;\n    canvas.height = video.videoHeight;\n  };\n\n  // 비디오의 메타데이터가 로드되면 캔버스 크기 조정\n  video.onloadedmetadata = resizeCanvas;\n\n  // 윈도우 크기가 변경될 때 캔버스 크기 재설정\n  window.addEventListener('resize', resizeCanvas);\n\n  // 이미지를 주기적으로 캡처하고 WebSocket을 통해 전송\n  const interval = setInterval(() => {\n    if (video.readyState === video.HAVE_ENOUGH_DATA) {\n      context.drawImage(video, 0, 0, canvas.width, canvas.height);\n\n      // 캔버스에서 이미지를 Base64 문자열로 추출\n      const imageData = canvas.toDataURL('image/jpeg');\n\n      // 이미지 데이터를 서버로 전송\n      if (myIndex.current === 0) {\n        socketRef.current.emit('image-capture-L', {\n          image: imageData\n        });\n      } else {\n        socketRef.current.emit('image-capture-R', {\n          image: imageData\n        });\n      }\n    }\n  }, 500);\n  return () => {\n    clearInterval(interval);\n    window.removeEventListener('resize', resizeCanvas);\n  };\n};\nexport default startCapturing;","map":{"version":3,"names":["startCapturing","stream","ref","canvasRef","socketRef","myIndex","video","current","canvas","context","getContext","resizeCanvas","width","videoWidth","height","videoHeight","onloadedmetadata","window","addEventListener","interval","setInterval","readyState","HAVE_ENOUGH_DATA","drawImage","imageData","toDataURL","emit","image","clearInterval","removeEventListener"],"sources":["/home/ubuntu/NMM/react-frontend/src/components/startCapturing.js"],"sourcesContent":["// startCapturing.js\n\n/**\n * 비디오 스트림에서 이미지를 캡처하고, 이를 WebSocket을 통해 서버로 전송하는 함수.\n * \n * @param {MediaStream} stream - 비디오 스트림 객체.\n * @param {React.RefObject} ref - 비디오 태그의 ref.\n * @param {React.RefObject} canvasRef - 캔버스 태그의 ref.\n * @param {Socket} socketRef - Socket.IO 클라이언트 인스턴스의 ref.\n */\nconst startCapturing = (stream, ref, canvasRef, socketRef, myIndex) => {\n    const video = ref.current;\n    const canvas = canvasRef.current;\n  \n    // 캔버스가 없다면 함수 종료\n    if (!canvas) return;\n  \n    const context = canvas.getContext('2d');\n  \n    // 캔버스 크기를 비디오와 동일하게 설정\n    const resizeCanvas = () => {\n      canvas.width = video.videoWidth;\n      canvas.height = video.videoHeight;\n    };\n  \n    // 비디오의 메타데이터가 로드되면 캔버스 크기 조정\n    video.onloadedmetadata = resizeCanvas;\n  \n    // 윈도우 크기가 변경될 때 캔버스 크기 재설정\n    window.addEventListener('resize', resizeCanvas);\n  \n    // 이미지를 주기적으로 캡처하고 WebSocket을 통해 전송\n    const interval = setInterval(() => {\n      if (video.readyState === video.HAVE_ENOUGH_DATA) {\n        context.drawImage(video, 0, 0, canvas.width, canvas.height);\n        \n        // 캔버스에서 이미지를 Base64 문자열로 추출\n        const imageData= canvas.toDataURL('image/jpeg');\n  \n        // 이미지 데이터를 서버로 전송\n        if(myIndex.current === 0){\n            socketRef.current.emit('image-capture-L', { image: imageData });\n        }\n        else {\n            socketRef.current.emit('image-capture-R', { image: imageData });\n        }\n      }\n    }, 500);\n  \n    return () => {\n      clearInterval(interval);\n      window.removeEventListener('resize', resizeCanvas);\n    };\n  };\n  \n  export default startCapturing;"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,cAAc,GAAGA,CAACC,MAAM,EAAEC,GAAG,EAAEC,SAAS,EAAEC,SAAS,EAAEC,OAAO,KAAK;EACnE,MAAMC,KAAK,GAAGJ,GAAG,CAACK,OAAO;EACzB,MAAMC,MAAM,GAAGL,SAAS,CAACI,OAAO;;EAEhC;EACA,IAAI,CAACC,MAAM,EAAE;EAEb,MAAMC,OAAO,GAAGD,MAAM,CAACE,UAAU,CAAC,IAAI,CAAC;;EAEvC;EACA,MAAMC,YAAY,GAAGA,CAAA,KAAM;IACzBH,MAAM,CAACI,KAAK,GAAGN,KAAK,CAACO,UAAU;IAC/BL,MAAM,CAACM,MAAM,GAAGR,KAAK,CAACS,WAAW;EACnC,CAAC;;EAED;EACAT,KAAK,CAACU,gBAAgB,GAAGL,YAAY;;EAErC;EACAM,MAAM,CAACC,gBAAgB,CAAC,QAAQ,EAAEP,YAAY,CAAC;;EAE/C;EACA,MAAMQ,QAAQ,GAAGC,WAAW,CAAC,MAAM;IACjC,IAAId,KAAK,CAACe,UAAU,KAAKf,KAAK,CAACgB,gBAAgB,EAAE;MAC/Cb,OAAO,CAACc,SAAS,CAACjB,KAAK,EAAE,CAAC,EAAE,CAAC,EAAEE,MAAM,CAACI,KAAK,EAAEJ,MAAM,CAACM,MAAM,CAAC;;MAE3D;MACA,MAAMU,SAAS,GAAEhB,MAAM,CAACiB,SAAS,CAAC,YAAY,CAAC;;MAE/C;MACA,IAAGpB,OAAO,CAACE,OAAO,KAAK,CAAC,EAAC;QACrBH,SAAS,CAACG,OAAO,CAACmB,IAAI,CAAC,iBAAiB,EAAE;UAAEC,KAAK,EAAEH;QAAU,CAAC,CAAC;MACnE,CAAC,MACI;QACDpB,SAAS,CAACG,OAAO,CAACmB,IAAI,CAAC,iBAAiB,EAAE;UAAEC,KAAK,EAAEH;QAAU,CAAC,CAAC;MACnE;IACF;EACF,CAAC,EAAE,GAAG,CAAC;EAEP,OAAO,MAAM;IACXI,aAAa,CAACT,QAAQ,CAAC;IACvBF,MAAM,CAACY,mBAAmB,CAAC,QAAQ,EAAElB,YAAY,CAAC;EACpD,CAAC;AACH,CAAC;AAED,eAAeX,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}